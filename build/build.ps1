[CmdletBinding()]
param(
  [switch]$UpdateSrcPsm1  # optional: also rewrite src\<ModuleName>.psm1 to a minimal autoloader
)

$ErrorActionPreference = 'Stop'

function Set-FileUtf8Bom {
  param(
    [Parameter(Mandatory)][string]$Path,
    [Parameter(Mandatory)][string]$Content
  )
  if ($PSVersionTable.PSVersion.Major -ge 6) {
    Set-Content -LiteralPath $Path -Value $Content -Encoding utf8BOM
  } else {
    # Windows PowerShell 5.1: UTF8 includes BOM
    Set-Content -LiteralPath $Path -Value $Content -Encoding UTF8
  }
}

Write-Host "=== BUILD START ===" -ForegroundColor Cyan

# Paths
$RepoRoot = Split-Path -Parent $PSScriptRoot
$Src      = Join-Path $RepoRoot 'src'
$DistRoot = Join-Path $RepoRoot 'dist'
Write-Host "[Paths]"
Write-Host ("  RepoRoot  : {0}" -f $RepoRoot)
Write-Host ("  Src       : {0}" -f $Src)
Write-Host ("  DistRoot  : {0}" -f $DistRoot)

# Locate single manifest
Write-Host "`n[Manifest] Scanning for *.psd1 under src..."
$psd1s = Get-ChildItem -Path $Src -Filter *.psd1
Write-Host ("  Found: {0}" -f $psd1s.Count)
if ($psd1s.Count -eq 0) { throw "No .psd1 found under src/." }
if ($psd1s.Count -gt 1) {
  $psd1s | ForEach-Object { Write-Warning ("  - {0}" -f $_.FullName) }
  throw "Multiple .psd1 files found under src/. Keep only one or add selection logic."
}

$ManifestPath = $psd1s[0].FullName
Write-Host ("  Using manifest: {0}" -f $ManifestPath)

# Parse & validate source manifest
Write-Host "`n[Manifest] Import & validate (source)..."
$Manifest = Import-PowerShellDataFile $ManifestPath
$tm       = Test-ModuleManifest -Path $ManifestPath -ErrorAction Stop
Write-Host ("  Name    : {0}" -f $tm.Name)
Write-Host ("  Version : {0}" -f $tm.Version)
Write-Host ("  Root    : {0}" -f $tm.RootModule)

# Module metadata
$ModuleName = [IO.Path]::GetFileNameWithoutExtension($ManifestPath)
if (-not $ModuleName -and $Manifest.RootModule) {
  $ModuleName = [IO.Path]::GetFileNameWithoutExtension($Manifest.RootModule)
}
if (-not $ModuleName) { throw "Cannot determine ModuleName from manifest filename or RootModule." }

if (-not $Manifest.ModuleVersion) { throw "ModuleVersion missing in $ManifestPath." }
$Version = [string]$Manifest.ModuleVersion

Write-Host "`n[Module]"
Write-Host ("  ModuleName : {0}" -f $ModuleName)
Write-Host ("  Version    : {0}" -f $Version)

# Output path
$Out = Join-Path $DistRoot ("{0}\{1}" -f $ModuleName, $Version)
Write-Host "`n[Output]"
Write-Host ("  Dist path  : {0}" -f $Out)

# Clean & copy
Write-Host "`n[Copy] Cleaning & copying src -> dist ..."
if (Test-Path $Out) {
  Write-Host ("  Removing existing: {0}" -f $Out)
  Remove-Item $Out -Recurse -Force
}
New-Item -ItemType Directory -Path $Out | Out-Null
Copy-Item -Path (Join-Path $Src '*') -Destination $Out -Recurse -Force
Write-Host "  Copy complete."

# Paths inside dist
$outPublic  = Join-Path $Out 'Public'
$outPrivate = Join-Path $Out 'Private'
$outClasses = Join-Path $Out 'Classes'
$psm1Path   = Join-Path $Out ("{0}.psm1" -f $ModuleName)
$distPsd1   = Join-Path $Out ("{0}.psd1" -f $ModuleName)

# Discover public functions by filename
Write-Host "`n[Public] Discovering functions in: $outPublic"
$publicFiles = @()
if (Test-Path $outPublic) {
  $publicFiles = Get-ChildItem -LiteralPath $outPublic -Filter *.ps1 -Recurse
}
$publicFunctionNames = $publicFiles |
  ForEach-Object { [IO.Path]::GetFileNameWithoutExtension($_.Name) } |
  Sort-Object -Unique

Write-Host ("  Found {0} public function file(s)." -f $publicFunctionNames.Count)
foreach ($fn in $publicFunctionNames) { Write-Host ("    + {0}" -f $fn) }

# Validate: filename vs function declaration (warn only)
Write-Host "`n[Validate] Checking each Public file defines matching 'function Name'..."
$bad = @()
foreach ($f in $publicFiles) {
  $expected = [IO.Path]::GetFileNameWithoutExtension($f.Name)
  $text     = Get-Content -LiteralPath $f.FullName -Raw
  if ($text -notmatch "(?ms)^\s*function\s+$([Regex]::Escape($expected))\b") {
    Write-Warning "  Mismatch: file '$($f.Name)' should define 'function $expected' (check name/spelling)."
    $bad += $f.Name
  }
}
if ($bad.Count -eq 0) { Write-Host "  OK: all match." }

# Build psm1 with explicit export list
Write-Host "`n[PSM1] Generating loader with explicit export list ..."
$header = @"
# ==============================================
# Auto-generated by build.ps1 on $(Get-Date -Format o)
# Do NOT edit this file in dist; edit sources in src\
# Module: $ModuleName  Version: $Version
# ==============================================

"@

$loadClasses = @"
# Load classes (if any)
if (Test-Path "`$PSScriptRoot\Classes") {
  Get-ChildItem -LiteralPath "`$PSScriptRoot\Classes" -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue |
    ForEach-Object { . `$_.FullName }
}
"@

$loadPrivate = @"
# Load private helpers (if any)
if (Test-Path "`$PSScriptRoot\Private") {
  Get-ChildItem -LiteralPath "`$PSScriptRoot\Private" -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue |
    ForEach-Object { . `$_.FullName }
}
"@

$loadPublic = @"
# Load public functions (if any)
if (Test-Path "`$PSScriptRoot\Public") {
  Get-ChildItem -LiteralPath "`$PSScriptRoot\Public" -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue |
    ForEach-Object { . `$_.FullName }
}
"@

# Build explicit export list literal
$exportArrayLiteral = if ($publicFunctionNames.Count -gt 0) {
  $quoted = $publicFunctionNames | ForEach-Object { "'$_'" }
  "@(`r`n    $($quoted -join ",`r`n    ")`r`n)"
} else { "@()" }

$exportBlock = @"
# Export public functions (explicit list)
Export-ModuleMember -Function $exportArrayLiteral
"@

$psm1Content = $header + $loadClasses + "`r`n" + $loadPrivate + "`r`n" + $loadPublic + "`r`n" + $exportBlock + "`r`n"
Set-FileUtf8Bom -Path $psm1Path -Content $psm1Content
Write-Host ("  Wrote: {0}" -f $psm1Path)

# ------------------------------
# Rebuild a CLEAN dist manifest
# ------------------------------
Write-Host "`n[Manifest] Rebuilding a clean dist manifest ..."
$srcMeta  = Import-PowerShellDataFile $ManifestPath

# sanitize PrivateData: only one PSData hashtable
$cleanPrivateData = @{ PSData = @{} }
if ($srcMeta.PrivateData -is [hashtable]) {
  if ($srcMeta.PrivateData.PSData -is [hashtable]) {
    $cleanPrivateData.PSData = $srcMeta.PrivateData.PSData
  }
}

# ensure arrays aren’t $null
$reqMods = @(); if ($srcMeta.RequiredModules)  { $reqMods = $srcMeta.RequiredModules }
$cmdlets = @(); if ($srcMeta.CmdletsToExport)  { $cmdlets = $srcMeta.CmdletsToExport }
$aliases = @(); if ($srcMeta.AliasesToExport)  { $aliases = $srcMeta.AliasesToExport }
$vars    = @(); if ($srcMeta.VariablesToExport){ $vars    = $srcMeta.VariablesToExport }

# root module and explicit export list
$rootModule     = "$ModuleName.psm1"
$funcsToExport  = $publicFunctionNames

# write a brand-new manifest file
if (Test-Path $distPsd1) { Remove-Item $distPsd1 -Force }
New-ModuleManifest -Path $distPsd1 `
  -RootModule        $rootModule `
  -ModuleVersion     $srcMeta.ModuleVersion `
  -Guid              $srcMeta.Guid `
  -Author            $srcMeta.Author `
  -CompanyName       $srcMeta.CompanyName `
  -Description       $srcMeta.Description `
  -PowerShellVersion $srcMeta.PowerShellVersion `
  -RequiredModules   $reqMods `
  -FunctionsToExport $funcsToExport `
  -CmdletsToExport   $cmdlets `
  -AliasesToExport   $aliases `
  -VariablesToExport $vars `
  -PrivateData       $cleanPrivateData | Out-Null

# begin FIX bug when it add : PSData = 'System.Collections.Hashtable'
# --- SANITIZE manifest: remove stray "PSData = 'System.Collections.Hashtable'" and its comment ---
$distText = Get-Content -LiteralPath $distPsd1 -Raw
# remove the exact bad line (and optional preceding "# PSData" comment)
$distText = $distText -replace '(?m)^\s*#\s*PSData\s*\r?\n\s*PSData\s*=\s*''System\.Collections\.Hashtable''\s*\r?\n',''
$distText = $distText -replace '(?m)^\s*PSData\s*=\s*''System\.Collections\.Hashtable''\s*\r?\n',''
Set-Content -LiteralPath $distPsd1 -Value $distText -Encoding UTF8

# sanity: ensure only one PSData key remains in the whole file
$dupMatches = ([regex]::Matches($distText,'(?m)^\s*PSData\s*='))
if ($dupMatches.Count -gt 1) { throw "Manifest still has multiple PSData entries after sanitation." }

# final verify
Test-ModuleManifest -Path $distPsd1 -ErrorAction Stop | Out-Null
# end  FIX bug when it add : PSData = 'System.Collections.Hashtable'

# post-build sanity: no stray "PSData = 'System.Collections.Hashtable'" and no duplicate PSData keys
$distText = Get-Content -LiteralPath $distPsd1 -Raw
if ($distText -match "PSData\s*=\s*'System\.Collections\.Hashtable'") {
  throw "Sanitization failed: stray ""PSData = 'System.Collections.Hashtable'"" in dist manifest."
}
$dup = ([regex]::Matches($distText,'(?m)^\s*PSData\s*='))
if ($dup.Count -gt 1) {
  throw "Sanitization failed: multiple PSData keys in dist manifest."
}

# final verify
$tmDist = Test-ModuleManifest -Path $distPsd1 -ErrorAction Stop
Write-Host ("  Dist manifest OK → {0} {1}" -f $tmDist.Name, $tmDist.Version)

# Optionally update the *source* psm1 to a minimal autoloader
if ($UpdateSrcPsm1) {
  $srcPsm1 = Join-Path $Src ("{0}.psm1" -f $ModuleName)
  Write-Host "`n[PSM1] Updating source loader (per -UpdateSrcPsm1): $srcPsm1"
  $srcLoader = @"
# Minimal autoloader for development (source)
if (Test-Path "`$PSScriptRoot\Classes") {
  Get-ChildItem -LiteralPath "`$PSScriptRoot\Classes" -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue |
    ForEach-Object { . `$_.FullName }
}
if (Test-Path "`$PSScriptRoot\Private") {
  Get-ChildItem -LiteralPath "`$PSScriptRoot\Private" -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue |
    ForEach-Object { . `$_.FullName }
}
if (Test-Path "`$PSScriptRoot\Public") {
  Get-ChildItem -LiteralPath "`$PSScriptRoot\Public" -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue |
    ForEach-Object { . `$_.FullName }
}
# Exports are explicit in the dist manifest/psm1 during packaging.
"@
  Set-FileUtf8Bom -Path $srcPsm1 -Content $srcLoader
  Write-Host "  Source psm1 updated."
} else {
  Write-Host "`n[PSM1] Source psm1 not changed (use -UpdateSrcPsm1 to rewrite)."
}

Write-Host "`n=== BUILD COMPLETE ===" -ForegroundColor Green
Write-Host ("Built {0} {1} at: {2}" -f $ModuleName, $Version, $Out)
